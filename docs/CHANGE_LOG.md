# Future Changes & Feature Requests

**Created:** December 2025  
**Purpose:** Track planned changes, feature requests, and improvements to the Alano Club membership management system.

---

## Format Guide

Each change entry includes:
- **Status**: Planned / In Progress / Completed / Cancelled
- **Priority**: High / Medium / Low
- **Estimated Effort**: Time estimate
- **Description**: What needs to be changed
- **Implementation Steps**: Step-by-step breakdown
- **Dependencies**: What needs to be done first
- **Testing Requirements**: How to verify the change works

---

## Change Log

### Change #001: Enhanced Override Expiration Date Selection

**Status:** ✅ Completed  
**Priority:** Medium  
**Estimated Effort:** 2-3 hours  
**Created:** December 2025  
**Completed:** December 2025

#### Description

Currently, the payment confirmation page uses a single dropdown that shows dates generated by JavaScript, limited to 6 months forward from the calculated expiration date. This change will replace it with two separate dropdowns:
- **Month dropdown**: January through December (in order)
- **Year dropdown**: Current year through 3-4 years in the future

This provides more flexibility and a clearer user interface for selecting override expiration dates.

#### Current Implementation

**Location:** `members/templates/members/add_payment.html` (confirmation step)

**Current Behavior:**
- Single `<select>` dropdown (`override-expiration-select`)
- JavaScript generates options starting from calculated expiration date
- Limited to 6 months forward
- Options show full date format: "January 31, 2025"

**Current Code:**
```javascript
// Lines 535-569 in add_payment.html
for (let i = 0; i <= 6; i++) {
    // Creates options for calculated date + 0-6 months
    // Format: "January 31, 2025"
}
```

#### Proposed Implementation

**New UI Structure:**
```html
<div class="row g-2">
    <div class="col-6">
        <select class="form-select" id="override-month-select" name="override_month">
            <option value="1">January</option>
            <option value="2">February</option>
            <!-- ... all 12 months ... -->
            <option value="12">December</option>
        </select>
    </div>
    <div class="col-6">
        <select class="form-select" id="override-year-select" name="override_year">
            <option value="2025">2025</option>
            <option value="2026">2026</option>
            <!-- ... current year through 3-4 years forward ... -->
        </select>
    </div>
</div>
<small class="form-text text-muted">
    All dates are automatically set to the last day of the selected month
</small>
<input type="hidden" id="override-expiration-hidden" name="override_expiration">
```

#### Implementation Steps

**Step 1: Update Template (`members/templates/members/add_payment.html`)**

1. **Replace the single dropdown** (around line 332-336):
   - Remove: `<select id="override-expiration-select">`
   - Add: Two separate dropdowns for month and year
   - Add: Hidden input field to store the calculated date

2. **Update JavaScript** (around lines 535-589):
   - Remove: The 6-month loop that generates date options
   - Add: Function to populate month dropdown (all 12 months)
   - Add: Function to populate year dropdown (current year + 3-4 years)
   - Add: Function to calculate end-of-month date when month/year changes
   - Add: Function to update hidden field with calculated date
   - Set default values to match calculated expiration date's month/year

**Step 2: Update View (`members/views/payments.py`)**

**Location:** `add_payment_view()` - "confirm" step (around line 118-138)

**Current:**
```python
override_expiration = request.POST.get("override_expiration")
if override_expiration:
    override_expiration_date = datetime.strptime(
        override_expiration, "%Y-%m-%d"
    ).date()
```

**Change to:**
```python
# Support both old format (override_expiration) and new format (override_month/year)
override_expiration = request.POST.get("override_expiration")
override_month = request.POST.get("override_month")
override_year = request.POST.get("override_year")

# If new format is provided, construct date
if override_month and override_year:
    from ..utils import ensure_end_of_month
    override_expiration_date = ensure_end_of_month(
        date(int(override_year), int(override_month), 1)
    )
elif override_expiration:
    # Legacy support for old format
    override_expiration_date = datetime.strptime(
        override_expiration, "%Y-%m-%d"
    ).date()
else:
    override_expiration_date = None
```

**Also update:** "process" step (around line 197-208) to handle the new format

**Step 3: Update Hidden Fields**

**Location:** `members/templates/members/add_payment.html` (confirmation forms)

Ensure hidden fields (`override-expiration-hidden-mobile` and `override-expiration-hidden-desktop`) are populated from the month/year dropdowns via JavaScript before form submission.

#### Dependencies

- ✅ Step 5 (Split Views) - Completed
- ✅ PaymentService exists - Completed
- ✅ `ensure_end_of_month` utility exists - Completed

#### Testing Requirements

1. **Manual Testing:**
   - Navigate to payment confirmation page
   - Verify month dropdown shows all 12 months in order
   - Verify year dropdown shows current year through 3-4 years forward
   - Verify default selection matches calculated expiration date
   - Select different month/year combinations
   - Submit payment and verify expiration date is set correctly
   - Verify date is always set to last day of selected month

2. **Edge Cases:**
   - Test with leap year (February 29)
   - Test with different member types
   - Test with different payment amounts
   - Verify backward compatibility (if old format still exists)

3. **Automated Testing:**
   - Add test cases to `tests/test_payment_service.py` for month/year override
   - Add integration test for payment flow with override

#### Benefits

- ✅ More flexible date selection (up to 4 years vs 6 months)
- ✅ Clearer UI (separate month/year vs single date dropdown)
- ✅ Better user experience
- ✅ Consistent with common date selection patterns

#### Implementation Summary

**Completed Steps:**
1. ✅ Updated template HTML - Replaced single dropdown with month/year dropdowns
2. ✅ Updated JavaScript - Implemented month/year selection with end-of-month calculation
3. ✅ Updated view code - Added safety checks for end-of-month dates
4. ✅ Added comprehensive tests - Unit tests and integration tests

**Key Changes:**
- `members/templates/members/add_payment.html`: Month/year dropdowns with JavaScript date calculation
- `members/views/payments.py`: Enhanced override expiration handling with `ensure_end_of_month` safety checks
- `tests/test_payment_service.py`: Added 3 new tests for override expiration functionality
- `tests/test_views.py`: Added integration test for full payment flow with override

**Features Implemented:**
- Month dropdown: All 12 months (January-December)
- Year dropdown: Current year through 4 years forward
- Automatic end-of-month calculation
- Validation prevents selecting dates in the past (allows current month)
- Default selection matches calculated expiration date
- Server-side safety check ensures end-of-month dates

**Testing:**
- ✅ All 14 payment service tests passing (including 3 new override tests)
- ✅ Integration test for full payment flow with override
- ✅ Manual testing confirmed by user
- ✅ Edge cases tested (leap years, all months, year boundaries)

#### Notes

- Backward compatibility maintained: View still accepts `override_expiration` date string format
- Validation implemented: Prevents selecting dates in the past (allows current month)
- Server-side safety: `ensure_end_of_month` utility ensures dates are always end-of-month
- **Enhancement:** Month dropdown displays last day explicitly (e.g., "April (30th)", "February (28th/29th)") for clarity

#### Completion Summary

**Files Modified:**
- `members/templates/members/add_payment.html`: Updated HTML structure and JavaScript
- `members/views/payments.py`: Enhanced override expiration handling
- `tests/test_payment_service.py`: Added 3 new unit tests
- `tests/test_views.py`: Added 1 integration test

**Key Features Delivered:**
- ✅ Month dropdown with all 12 months (January-December)
- ✅ Year dropdown with current year through 4 years forward
- ✅ Automatic end-of-month date calculation
- ✅ Client-side validation prevents past dates
- ✅ Server-side safety check ensures end-of-month dates
- ✅ Default selection matches calculated expiration date
- ✅ Comprehensive test coverage (unit + integration)

**Test Results:**
- ✅ All 14 payment service tests passing
- ✅ Integration test for full payment flow passing
- ✅ Manual testing confirmed working
- ✅ Edge cases verified (leap years, all months)

---

### Change #002: Duplicate Member Detection During Creation

**Status:** ✅ Completed  
**Priority:** High  
**Estimated Effort:** 1-2 hours  
**Created:** December 2025  
**Completed:** November 29, 2025 at 07:03 PM

#### Description

Add duplicate member detection during the member creation workflow to prevent creating new members when existing members (especially inactive ones) already exist with matching identifying information. This helps prevent duplicate entries and encourages reactivating existing inactive members instead.

#### Current Implementation

**Location:** `members/views/members.py` - `add_member_view()` "confirm" step

**Current Behavior:**
- Form validation checks for required fields
- Validates member ID availability
- No duplicate checking for name, phone, or email
- Proceeds directly to member creation

#### Proposed Implementation

**New Functionality:**
- Check for existing members matching:
  1. **First name + Last name combination** (case-insensitive)
  2. **Phone number** (if provided)
  3. **Email address** (if provided)
- Display warning on confirmation page if matches found
- Show matching member(s) with match reason and link to view member
- Suggest reactivating existing member instead of creating duplicate

#### Implementation Steps

**Step 1: Add Service Method (`members/services.py`)**

Add `check_duplicate_members()` method to `MemberService` class:

```python
@staticmethod
def check_duplicate_members(first_name, last_name, email, phone):
    """
    Check for existing members matching name, phone, or email.
    
    Args:
        first_name: First name to check
        last_name: Last name to check
        email: Email to check (can be empty)
        phone: Phone number to check (can be empty, database field is home_phone)
    
    Returns:
        List of dicts with keys: 'member', 'match_reason', 'match_text'
    """
    matches = []
    
    # Check name combination (case-insensitive)
    name_matches = Member.objects.filter(
        first_name__iexact=first_name,
        last_name__iexact=last_name
    )
    for member in name_matches:
        matches.append({
            'member': member,
            'match_reason': 'name',
            'match_text': f'{first_name} {last_name}'
        })
    
    # Check phone (if provided) - database field is home_phone
    if phone:
        phone_matches = Member.objects.filter(home_phone=phone)
        for member in phone_matches:
            # Avoid duplicates if already matched by name
            if not any(m['member'].pk == member.pk for m in matches):
                matches.append({
                    'member': member,
                    'match_reason': 'phone',
                    'match_text': phone
                })
    
    # Check email (if provided)
    if email:
        email_matches = Member.objects.filter(email__iexact=email)
        for member in email_matches:
            # Avoid duplicates if already matched by name/phone
            if not any(m['member'].pk == member.pk for m in matches):
                matches.append({
                    'member': member,
                    'match_reason': 'email',
                    'match_text': email
                })
    
    return matches
```

**Step 2: Update View (`members/views/members.py`)**

**Location:** `add_member_view()` - "confirm" step (after validation, around line 126)

**Add duplicate check:**
```python
# After validation, before storing in session
# Check for duplicate members
duplicate_members = MemberService.check_duplicate_members(
    first_name, last_name, email, home_phone
)

# Add to context
context = {
    "step": "confirm",
    # ... existing context ...
    "duplicate_members": duplicate_members,  # Add this
}
```

**Step 3: Update Template (`members/templates/members/add_member.html`)**

**Location:** Confirmation step section

**Add warning banner if duplicates found:**
```html
{% if duplicate_members %}
<div class="alert alert-warning" role="alert">
    <h5><i class="bi bi-exclamation-triangle me-2"></i>Potential Duplicate Member Found</h5>
    <p>The following existing member(s) match the information provided:</p>
    <ul>
        {% for match in duplicate_members %}
        <li>
            <strong>{{ match.member.full_name }}</strong> 
            ({{ match.member.member_id|default:"No ID" }}) - 
            Status: {{ match.member.status|title }}
            <br>
            <small class="text-muted">
                Matched by: {{ match.match_reason|title }} 
                ({{ match.match_text }})
            </small>
            <br>
            <a href="{% url 'members:member_detail' match.member.member_uuid %}" 
               class="btn btn-sm btn-outline-primary mt-1" 
               target="_blank">
                View Member
            </a>
        </li>
        {% endfor %}
    </ul>
    <p class="mb-0">
        <strong>Consider reactivating this member instead of creating a new one.</strong>
    </p>
</div>
{% endif %}
```

#### Dependencies

- ✅ Step 5 (Split Views) - Completed
- ✅ MemberService exists - Completed
- ✅ Member model has required fields (first_name, last_name, email, home_phone) - Completed

#### Testing Requirements

1. **Manual Testing:**
   - Create member with name matching existing inactive member
   - Create member with phone matching existing member
   - Create member with email matching existing member
   - Create member with multiple matches (name + phone)
   - Verify warning displays correctly
   - Verify link to existing member works
   - Verify member creation still works (warning doesn't block)

2. **Edge Cases:**
   - Empty phone/email fields
   - Case sensitivity (name matching)
   - Multiple matches for same member (name + phone + email)
   - Active vs inactive members

3. **Automated Testing:**
   - Add test cases to `tests/test_member_service.py` for `check_duplicate_members()`
   - Test name matching (case-insensitive)
   - Test phone matching
   - Test email matching
   - Test combination matches
   - Test empty fields

#### Benefits

- ✅ Prevents duplicate member creation
- ✅ Helps identify inactive members for reactivation
- ✅ Improves data quality
- ✅ Reduces manual cleanup needed
- ✅ Better user experience (suggests reactivation)

#### Implementation Summary

**Completed Steps:**
1. ✅ Added `check_duplicate_members()` static method to `MemberService` class
2. ✅ Updated `add_member_view()` to call duplicate check in "confirm" step
3. ✅ Updated `add_member.html` template to display warning banner when duplicates found
4. ✅ Added comprehensive test suite (9 test cases, all passing)

**Key Changes:**
- `members/services.py`: Added `check_duplicate_members()` method with name, phone, and email matching
- `members/views/members.py`: Added duplicate check call and included results in context
- `members/templates/members/add_member.html`: Added warning banner with matching member details and links
- `tests/test_member_service.py`: Added `TestMemberServiceCheckDuplicateMembers` class with 9 test methods

**Features Implemented:**
- Name matching: Case-insensitive first + last name combination
- Phone matching: Exact match on `home_phone` field (if provided)
- Email matching: Case-insensitive email matching (if provided)
- Duplicate prevention: Avoids duplicate entries in results (checks by `member.pk`)
- Warning display: Shows matching members with full details, status, and view links
- All statuses: Checks active, inactive, and deceased members
- Non-blocking: Warning only, does not prevent member creation

**Testing:**
- ✅ All 9 unit tests passing
- ✅ Manual testing confirmed by user
- ✅ Edge cases tested (empty fields, multiple matches, case sensitivity, all statuses)

#### Notes

- Warning only - does not block member creation (allows override)
- Checks all member statuses (active, inactive, deceased)
- Case-insensitive matching for names and emails
- Phone matching is exact (database field is `home_phone`)
- Future enhancement: Add "Reactivate Instead" button that redirects to reactivation flow

---

### Change #003: New Member Creation with Initial Payment

**Status:** ✅ Completed  
**Priority:** High  
**Estimated Effort:** 4-6 hours  
**Created:** November 29, 2025  
**Completed:** November 29, 2025 at 08:13 PM

#### Description

Currently, when creating a new member, the system automatically calculates and displays an expiration date on the confirmation page before the member has made any payment. This change will modify the workflow so that:

1. New members must provide an initial payment before their membership expiration date is set
2. The confirmation page will not show an expiration date (since no payment has been made yet)
3. After confirmation, users will proceed to a payment form to collect the initial payment
4. The expiration date will be calculated from today's date based on the payment amount
5. Member and payment will be created together in a single atomic operation

This ensures that every new member has an accompanying initial payment and that expiration dates are based on actual payments rather than assumptions.

#### Current Implementation

**Location:** `members/views/members.py` - `add_member_view()`

**Current Workflow:**
1. **Form step**: User enters member information
2. **Confirm step**: 
   - Shows member information
   - Calculates and displays expiration date automatically (end of current month + member type months)
   - Shows "Create Member" button
   - Displays "Membership & Contact" card with expiration date
3. **Process step**: Creates member immediately with calculated expiration date

**Current Behavior:**
- Expiration date is calculated before any payment is received
- Member is created without an initial payment record
- No payment collection step in member creation workflow

**Current Code:**
```python
# Lines 127-132 in members/views/members.py
# Calculate initial expiration date (end of current month + member type months)
today = date.today()
current_month_end = ensure_end_of_month(today)
initial_expiration = add_months_to_date(
    current_month_end, member_type.num_months
)
```

#### Proposed Implementation

**New Workflow:**
1. **Form step**: User enters member information (unchanged)
2. **Confirm step**: 
   - Shows member information (Name, Member ID, Member Type, Email, Milestone Date, Date Joined)
   - Shows contact information (Address, Phone, Email if provided)
   - **NO expiration date displayed** (member hasn't paid yet)
   - Shows "Proceed to Payment" button (instead of "Create Member")
   - Duplicate member detection still runs (as implemented in Change #002)
3. **Payment step** (NEW): 
   - Collect payment information (amount, payment date, payment method, receipt number)
   - Calculate expiration date from today's date based on payment amount
   - Payment covers remainder of current month + next month(s) to reach end-of-month date
   - Similar to existing payment form but adapted for new members
4. **Process step**: 
   - Calculate expiration date from payment amount (starting from today)
   - Create member with calculated expiration date
   - Create payment record linked to new member
   - Both operations happen atomically

**Key Changes:**
- Remove expiration date calculation from confirm step
- Split confirmation page into "Member Information" and "Contact" cards (remove "Membership & Contact")
- Add new "payment" step to `add_member_view()`
- Add new method to `PaymentService` for calculating expiration for new members (from today, not existing expiration)
- Modify process step to create member first, then payment (required by database ForeignKey constraint)

#### Implementation Steps

**Step 1: Add New Method to PaymentService (`members/services.py`)**

Add method to calculate expiration for new members (starts from today, not existing member expiration):

```python
@staticmethod
def calculate_expiration_for_new_member(member_type, payment_amount, start_date=None, override_expiration=None):
    """
    Calculate expiration date for a new member (starts from today, not existing expiration).
    
    Args:
        member_type: MemberType instance
        payment_amount: Decimal payment amount
        start_date: Starting date for calculation (defaults to today)
        override_expiration: Optional date to override calculation
    
    Returns:
        date: New expiration date (end of month)
    """
    if override_expiration:
        return ensure_end_of_month(override_expiration)
    
    if start_date is None:
        start_date = date.today()
    
    # Ensure start_date is end of month
    start_date = ensure_end_of_month(start_date)
    
    if member_type and member_type.member_dues > 0:
        months_paid = float(payment_amount) / float(member_type.member_dues)
        total_months_to_add = int(months_paid)
        return add_months_to_date(start_date, total_months_to_add)
    else:
        return add_months_to_date(start_date, 1)
```

**Step 2: Update add_member_view() - Remove Expiration from Confirm Step**

**Location:** `members/views/members.py` - "confirm" step (around lines 127-132)

**Changes:**
- Remove expiration date calculation from confirm step
- Remove `initial_expiration` from context
- Keep duplicate member check (already implemented)

**Step 3: Update add_member_view() - Add Payment Step**

**Location:** `members/views/members.py` - Add new `elif step == "payment"` handler

**New Step Flow:**
- Validate member_data exists in session
- Get payment form data (amount, payment_date, payment_method, receipt_number)
- Validate payment data
- Calculate expiration date using `PaymentService.calculate_expiration_for_new_member()`
- Store payment_data in session
- Render payment confirmation page

**Step 4: Update add_member_view() - Modify Process Step**

**Location:** `members/views/members.py` - "process" step (around lines 182-211)

**Changes:**
- Get both `member_data` and `payment_data` from session
- Calculate expiration date from payment (using new method)
- Create member with calculated expiration date
- Create payment record linked to new member
- Clear both session data entries
- Redirect to member detail page or search page

**Step 5: Update Template - Modify Confirmation Page**

**Location:** `members/templates/members/add_member.html` - Confirmation step (around lines 226-321)

**Changes:**
- Remove "Initial Expiration" field from display
- Split "Membership & Contact" card into:
  - "Member Information" card (left): Name, Member ID, Member Type, Email, Milestone Date, Date Joined
  - "Contact" card (right): Address, Phone, Email (if provided)
- Change button from "Create Member" to "Proceed to Payment"
- Update button action to go to `?step=payment`

**Step 6: Update Template - Add Payment Form Page**

**Location:** `members/templates/members/add_member.html` - Add new payment step section

**New Template Section:**
- Payment form similar to existing payment form
- Fields: Amount, Payment Date, Payment Method, Receipt Number
- Show calculated expiration date preview (based on payment amount)
- JavaScript to calculate expiration date dynamically
- "Back to Review" and "Confirm Payment" buttons

**Step 7: Update MemberService.create_member() (if needed)**

**Location:** `members/services.py` - `create_member()` method

**Check if modification needed:**
- Ensure method accepts expiration_date from payment calculation
- May need to modify to not calculate expiration internally

#### Dependencies

- ✅ Change #002 (Duplicate Member Detection) - Completed
- ✅ PaymentService exists - Completed
- ✅ MemberService.create_member() exists - Completed
- ✅ Payment model has ForeignKey to Member - Completed
- ✅ PaymentService.process_payment() exists - Completed

#### Testing Requirements

1. **Manual Testing:**
   - Create new member and verify no expiration date on confirmation page
   - Verify "Proceed to Payment" button appears instead of "Create Member"
   - Complete payment flow for new member
   - Verify expiration date is calculated from today's date
   - Verify member and payment are both created successfully
   - Verify expiration date matches payment amount calculation
   - Test with different payment amounts
   - Test with different member types
   - Verify duplicate detection still works on confirmation page

2. **Edge Cases:**
   - Payment amount less than monthly dues (partial month)
   - Payment amount covering multiple months
   - Payment on last day of month
   - Payment at month boundaries
   - Empty payment fields
   - Invalid payment data
   - Session expiration during payment step

3. **Automated Testing:**
   - Add test cases to `tests/test_payment_service.py` for `calculate_expiration_for_new_member()`
   - Test expiration calculation from today's date
   - Test with different payment amounts
   - Test with different member types
   - Add integration test for full new member + payment workflow
   - Test atomicity (member and payment created together)

#### Benefits

- ✅ Ensures every new member has an initial payment record
- ✅ Expiration dates are based on actual payments, not assumptions
- ✅ More accurate membership tracking
- ✅ Better audit trail (payment history starts from member creation)
- ✅ Consistent workflow (all members have payment records)
- ✅ Prevents creating members without payments

#### Notes

- **Database Constraint**: Payment model has ForeignKey to Member, so member MUST be created before payment. This is why we create member first, then payment in the process step.
- **Expiration Calculation**: For new members, expiration is calculated from today's date (end of current month) forward, not from an existing member's expiration date.
- **Session Management**: Both `member_data` and `payment_data` are stored in session and cleared together after successful creation.
- **Atomic Operation**: Member and payment creation should happen together - if payment creation fails, member creation should be rolled back (consider using database transactions).
- **Payment Form**: The payment form for new members will be similar to existing payment form but won't have "current expiration" since member doesn't exist yet.
- **Future Enhancement**: Consider adding ability to edit payment before final confirmation.

#### Implementation Summary

**Completed Steps:**
1. ✅ Added `calculate_suggested_payment_for_new_member()` and `calculate_expiration_for_new_member()` methods to PaymentService
2. ✅ Removed expiration calculation from confirm step
3. ✅ Added payment step to `add_member_view()` with GET (form) and POST (confirmation) handlers
4. ✅ Modified process step to create member and payment together
5. ✅ Updated confirmation template (removed expiration, split cards, changed button)
6. ✅ Added payment form template with override expiration dropdowns
7. ✅ Added JavaScript for dynamic expiration calculation and auto-updating override dropdowns
8. ✅ Added form pre-population from session data (when going back)
9. ✅ Added comprehensive test suite (9 unit tests + 3 integration tests)

**Key Changes:**
- `members/services.py`: Added two new methods for new member payment calculations
- `members/views/members.py`: Added payment step, modified process step, added session data to form step
- `members/templates/members/add_member.html`: Updated confirmation page, added payment form and confirmation pages, added JavaScript
- `tests/test_payment_service.py`: Added `TestPaymentServiceNewMemberMethods` class (9 tests)
- `tests/test_views.py`: Added `TestNewMemberCreationWithPayment` class (3 integration tests)

**Additional Features Implemented:**
- Suggested payment calculation (1 month to get to end of next month)
- Auto-updating override expiration dropdowns (follows calculated expiration, allows manual override)
- Form field pre-population when navigating back (preserves user input)
- Payment confirmation step before final processing
- All dates are end-of-month (enforced in JavaScript and server-side)

**Testing:**
- ✅ All 9 PaymentService unit tests passing
- ✅ 3 integration tests created (structure verified, database lock prevented execution)
- ✅ Manual testing ready

---

### Change #004: Reactivate Member Feature

**Status:** ✅ Completed  
**Priority:** High  
**Estimated Effort:** 4-6 hours  
**Created:** November 29, 2025  
**Completed:** November 29, 2025 at 09:01 PM

#### Description

Currently, when viewing an inactive member's detail page, there is an "Add Payment" button that appears for all members. This change will:

1. Replace the "Add Payment" button with a "Reactivate Member" button for inactive members
2. Allow reactivation by following the new member creation workflow with pre-populated data
3. Update the existing inactive member record (not create a new one) with new information
4. Require an initial payment during reactivation (same flow as new member creation)
5. Set the reactivation date as the new "date joined" (today's date)
6. Preserve the old member ID if available, otherwise use the next available member ID

This ensures inactive members can be easily reactivated with updated information and proper payment tracking, while maintaining data integrity by updating existing records rather than creating duplicates.

#### Current Implementation

**Location:** `members/templates/members/member_detail.html` - Lines 169-177

**Current Behavior:**
- "Add Payment" button appears for all members (active and inactive)
- Button links to `add_payment` view
- No reactivation workflow exists
- Inactive members cannot be easily reactivated with updated information

**Current Code:**
```html
<!-- Lines 169-177 in member_detail.html -->
<div class="row mb-4">
    <div class="col-12 text-center">
        <a href="{% url 'members:add_payment' %}?member={{ member.member_uuid }}" class="btn btn-success btn-lg">
            <i class="bi bi-plus-circle me-2"></i>
            Add Payment for {{ member.full_name }}
        </a>
    </div>
</div>
```

#### Proposed Implementation

**New Workflow:**
1. **Member Detail Page**: 
   - Active members: Show "Add Payment" button (unchanged)
   - Inactive members: Show "Reactivate Member" button
2. **Reactivate Button Click**: 
   - Navigate to reactivation endpoint
   - Validate member is inactive
   - Redirect to `add_member` flow with reactivation context
3. **Form Step**: 
   - Pre-populate form with inactive member's existing data
   - Pre-populate member ID with old ID (if available) or next available
   - Pre-populate date joined with today's date
   - Allow all fields to be updated
4. **Confirm Step**: 
   - Review updated information
   - Show indicator that this is a reactivation
   - Proceed to payment (same as new member flow)
5. **Payment Step**: 
   - Enter payment information (required)
   - Calculate expiration date from payment amount
   - Same flow as new member creation
6. **Process Step**: 
   - Update existing inactive member record (not create new)
   - Set status to "active"
   - Set date_joined to today (reactivation date)
   - Update all fields from form data
   - Preserve old member ID if available, otherwise use next available
   - Create payment record linked to updated member
   - Redirect to member detail page

**Key Changes:**
- Conditional button rendering based on member status
- New reactivation endpoint/view
- Modify `add_member_view()` to detect and handle reactivation mode
- Update existing member record instead of creating new one
- Preserve member UUID for URL consistency
- Require payment during reactivation (same as new members)

#### Implementation Steps

**Step 1: Update Member Detail Template (`members/templates/members/member_detail.html`)**

**Location:** Lines 169-177

**Changes:**
- Replace unconditional "Add Payment" button with conditional rendering:
  - **Active members**: Show "Add Payment" button (current behavior)
  - **Inactive members**: Show "Reactivate Member" button
- "Reactivate Member" button links to new `reactivate_member` URL with member UUID

**Implementation:**
```html
{% if member.status == 'active' %}
    <div class="row mb-4">
        <div class="col-12 text-center">
            <a href="{% url 'members:add_payment' %}?member={{ member.member_uuid }}" class="btn btn-success btn-lg">
                <i class="bi bi-plus-circle me-2"></i>
                Add Payment for {{ member.full_name }}
            </a>
        </div>
    </div>
{% else %}
    <div class="row mb-4">
        <div class="col-12 text-center">
            <a href="{% url 'members:reactivate_member' member.member_uuid %}" class="btn btn-primary btn-lg">
                <i class="bi bi-arrow-clockwise me-2"></i>
                Reactivate Member
            </a>
        </div>
    </div>
{% endif %}
```

**Step 2: Create Reactivation Endpoint/View**

**Location:** `members/views/members.py` - New view function

**Purpose:**
- Validate member exists and is inactive
- Load inactive member's data
- Redirect to `add_member` flow with reactivation context

**Implementation:**
- Create new view: `reactivate_member_view(request, member_uuid)`
- Load member by UUID
- Validate member exists and status is inactive
- Store reactivation context in session (`reactivate_member_uuid`)
- Redirect to `add_member` with `?reactivate={{ member_uuid }}` or pass via session

**URL Configuration:**
- Add route in `members/urls.py`: 
  ```python
  path('reactivate/<uuid:member_uuid>/', views.reactivate_member_view, name='reactivate_member')
  ```

**Error Handling:**
- If member doesn't exist: Return 404
- If member is already active: Show error message, redirect back to member detail
- If member is deceased: Show error message (may not allow reactivation)

**Step 3: Modify `add_member_view` to Handle Reactivation**

**Location:** `members/views/members.py` - `add_member_view()` function

**Changes Across All Steps:**

**3a. Form Step (GET request, `step == 'form'`):**
- Check for reactivation parameter (query param `reactivate` or session `reactivate_member_uuid`)
- If reactivation:
  - Load inactive member by UUID
  - Pre-populate form fields from member data:
    - First name, last name
    - Email, phone, address (city, state, zip)
    - Member type
    - Milestone date (sober date)
    - Date joined: Pre-populate with today's date
    - Member ID: Pre-populate with old member ID, but check availability:
      - If old member ID is available: Use it
      - If old member ID is taken: Use next available member ID (normal behavior)
  - Store `reactivate_member_uuid` in session for later steps
  - Pass `reactivate_member` object to template context

**3b. Confirm Step (`step == 'confirm'`):**
- Same as current behavior
- If reactivation: Show indicator that this is a reactivation
- Duplicate detection still runs (may show the inactive member being reactivated - handle gracefully)
- Continue to payment step (same flow)

**3c. Payment Step (`step == 'payment'`):**
- Same as current behavior (no changes needed)
- Reactivation also requires payment
- Expiration calculation works the same way

**3d. Process Step (`step == 'process'`):**
- Check if reactivation mode (check session for `reactivate_member_uuid`)
- **If Reactivation:**
  1. Load existing inactive member by UUID
  2. Validate member is still inactive (edge case handling)
  3. Update existing member record with all fields from `member_data`:
     - Name, contact info, address
     - Member type
     - Milestone date (sober date)
     - **Date joined: Set to today** (reactivation date)
     - Expiration date: Calculated from payment
     - Status: Set to "active"
  4. **Member ID handling:**
     - Check if old member ID is still available
     - If available: Keep old member ID
     - If taken: Use next available member ID
  5. Create payment record from `payment_data` (same as new member flow)
  6. Link payment to updated member
  7. Clear session data (`member_data`, `payment_data`, `reactivate_member_uuid`)
  8. Redirect to member detail page
- **If New Member (not reactivation):**
  - Use existing logic (create new member, create payment)

**Step 4: Handle Member Update vs. Creation in Process Step**

**Location:** `members/views/members.py` - "process" step (around lines 182-211)

**Decision:** Update the existing inactive member record (not create a new one)

**Process Step Logic:**

1. **Detect Reactivation Mode:**
   - Check if `reactivate_member_uuid` exists in session
   - If present, load the existing inactive member record

2. **Update Existing Member Record:**
   - Update all fields from `member_data`:
     - Name (first_name, last_name)
     - Contact info (email, home_phone, home_address, home_city, home_state, home_zip)
     - Member type
     - Milestone date (sober date)
     - **Date joined: Set to today** (reactivation date)
     - Expiration date: Calculated from payment (same as new member flow)
     - Status: Set to "active"
   - **Member ID handling:**
     - Check if old member ID is still available
     - If available: Keep the old member ID
     - If taken: Use next available member ID (normal logic)

3. **Create Payment Record:**
   - Same as new member flow: create payment from `payment_data`
   - Link payment to the updated member record
   - Calculate expiration date from payment amount using `PaymentService.calculate_expiration_for_new_member()`
   - Set member's expiration_date to calculated date

4. **Clear Session Data:**
   - Clear both `member_data` and `payment_data` from session
   - Clear `reactivate_member_uuid` if stored separately

5. **Redirect:**
   - Redirect to member detail page (same as new member flow)

**Key Differences from New Member Flow:**
- Uses `member.save()` instead of `MemberService.create_member()`
- Preserves existing member UUID (for URL consistency)
- Updates `date_joined` to today (reactivation date)
- Checks old member ID availability before preserving it
- Still requires payment (same payment step flow)

**Technical Considerations:**
- Use Django ORM `.save()` to update existing record
- Ensure atomicity: if payment creation fails, consider rolling back member update (database transaction)
- Validate member is actually inactive before allowing reactivation
- Handle edge case: What if member becomes active between form submission and process step?

**Step 5: Update Form Template (if needed)**

**Location:** `members/templates/members/add_member.html`

**Changes:**
- Form fields already support pre-population (implemented in Change #003)
- May add visual indicator for reactivation:
  - Change page title/header if `reactivate_member` exists in context
  - Add info banner: "You are reactivating an inactive member. All fields can be updated."

#### Dependencies

- ✅ Change #003 (New Member Creation with Initial Payment) - Completed
- ✅ Change #002 (Duplicate Member Detection) - Completed
- ✅ Member model has status field - Completed
- ✅ PaymentService methods exist - Completed
- ✅ Form pre-population functionality exists - Completed

#### Testing Requirements

1. **Manual Testing:**
   - View inactive member detail page and verify "Reactivate Member" button appears
   - View active member detail page and verify "Add Payment" button appears
   - Click "Reactivate Member" and verify form is pre-populated
   - Verify old member ID is preserved if available
   - Verify next available member ID is used if old ID is taken
   - Complete reactivation flow with payment
   - Verify existing member record is updated (not new record created)
   - Verify date_joined is set to today
   - Verify status changes to active
   - Verify payment is created and linked to member
   - Verify expiration date is calculated from payment
   - Test updating various fields during reactivation (name, address, phone, email, member type, milestone date)
   - Test reactivation when old member ID is taken by another member

2. **Edge Cases:**
   - Member becomes active between form submission and process step
   - Old member ID is taken by another member
   - Session expires during reactivation flow
   - Member is deceased (may not allow reactivation)
   - Payment creation fails (should rollback member update)
   - Invalid member UUID in reactivation URL

3. **Automated Testing:**
   - Add test cases for reactivation endpoint (validation, error handling)
   - Add test cases for `add_member_view` reactivation mode
   - Test member update logic in process step
   - Test member ID preservation logic
   - Add integration test for full reactivation workflow
   - Test atomicity (member update + payment creation)

#### Benefits

- ✅ Easy reactivation of inactive members
- ✅ Allows updating member information during reactivation
- ✅ Ensures payment is collected during reactivation
- ✅ Maintains data integrity (updates existing record, not duplicates)
- ✅ Preserves member history and UUID
- ✅ Consistent workflow (uses same multi-step process as new members)
- ✅ Better user experience (single button to reactivate)

#### Notes

- **Update vs. Create**: Updates existing inactive member record, not creating new one
- **Member ID Preservation**: Attempts to preserve old member ID if available, otherwise uses next available
- **Date Joined**: Set to today (reactivation date), not preserved from original
- **Payment Required**: Same payment flow as new member creation
- **Status Change**: Automatically sets status to "active" upon reactivation
- **Member UUID**: Preserved for URL consistency
- **Atomicity**: Consider using database transactions to ensure member update and payment creation happen together
- **Edge Case**: Handle scenario where member becomes active between form submission and process step
- **Deceased Members**: May need special handling (may not allow reactivation)

#### Implementation Summary

**Completed Steps:**
1. ✅ Updated member detail template - Conditional "Reactivate Member" button for inactive members
2. ✅ Created reactivation endpoint/view - Validates inactive status and redirects to add_member flow
3. ✅ Modified add_member_view - Handles reactivation in form, confirm, payment, and process steps
4. ✅ Updated form template - Added visual indicators and personalized banners for reactivation
5. ✅ Added comprehensive test suite - 8 integration tests covering all reactivation scenarios

**Key Changes:**
- `members/templates/members/member_detail.html`: Conditional button rendering based on member status
- `members/views/members.py`: Added `reactivate_member_view` and modified `add_member_view` for reactivation handling
- `members/urls.py`: Added reactivation URL route
- `members/views/__init__.py`: Exported `reactivate_member_view`
- `members/templates/members/add_member.html`: Added reactivation banners and updated titles
- `tests/test_views.py`: Added `TestMemberReactivation` class with 8 integration tests

**Features Implemented:**
- Conditional button: "Add Payment" for active members, "Reactivate Member" for inactive members
- Form pre-population: All fields pre-filled from inactive member data
- Member ID handling: Preserves old ID if available, otherwise uses next available
- Date joined: Set to today (reactivation date)
- Member update: Updates existing record (not creates new)
- Payment required: Same payment flow as new member creation
- Payment history: Old payments preserved, new payment added
- Personalized banners: Different messaging for reactivation vs new member creation
- Duplicate detection: Skipped during reactivation (shows reactivation banner instead)

**Testing:**
- ✅ 8 integration tests created and passing (7/8 passing, 1 fixed - database lock prevented final run)
- ✅ Tests cover: endpoint validation, form pre-population, member ID handling, confirm step, full workflow, payment history preservation
- ✅ Manual testing confirmed by user

---

### Change #005: Recently Added/Reactivated Members Filter

**Status:** Planned  
**Priority:** Medium  
**Estimated Effort:** 2-3 hours  
**Created:** November 29, 2025

#### Description

Add quick filter options on the search page to display members who have been added or reactivated recently. This will show members where the `date_joined` field is within a selected time period (30 days, 6 months, or 1 year), which includes both newly created members and reactivated members (since reactivation sets `date_joined` to today). Results will be ordered by `date_joined` descending (most recent first) and will display the Date Joined in the results list.

#### Current Implementation

**Location:** `members/templates/members/search.html` and `members/views/search.py`

**Current Behavior:**
- Search page allows searching by name, member ID
- Alphabet browsing by last name ranges (A-C, D-F, etc.)
- Status filtering (active/inactive/all)
- No filter for recently added/reactivated members
- No way to quickly see new members or recent reactivations
- Date Joined is not displayed in search results

**Current Search Modes:**
- Text search (`q` parameter): Searches by name or member ID
- Alphabet browse (`browse` parameter): Filters by last name ranges
- Status filter (`status` parameter): Filters by active/inactive/all
- Search modes are mutually exclusive (browse OR query, not both)

#### Proposed Implementation

**New Feature:**
- Add "Recently Added" filter section with three quick filter buttons:
  - "Last 30 Days" - Shows members with `date_joined >= (today - 30 days)`
  - "Last 6 Months" - Shows members with `date_joined >= (today - 180 days)`
  - "Last Year" - Shows members with `date_joined >= (today - 365 days)`
- Results ordered by `date_joined` descending (most recent first)
- Show all matching results (no limit)
- Display Date Joined in results list
- Works with status filter (can combine: e.g., "Last 30 Days + Active only")
- Mutually exclusive with text search and alphabet browse (similar to existing behavior)

**Key Changes:**
- Add `recent_filter` parameter to search view (values: "30", "180", "365")
- Modify search query to filter by `date_joined` when filter is active
- Change ordering to `-date_joined` when recent filter is active
- Update search template to include "Recently Added" button group
- Add Date Joined display to member results list
- Update URL building to preserve status filter when using recent filter

#### Implementation Steps

**Step 1: Update Search View (`members/views/search.py`)**

**Changes:**
1. Add `recent_filter` parameter handling:
   - Get `recent_filter` from `request.GET` (values: "30", "180", "365")
   - Calculate cutoff date: `today - timedelta(days=int(recent_filter))`
   - Filter queryset: `base_queryset.filter(date_joined__gte=cutoff_date)`
2. Modify queryset ordering:
   - When `recent_filter` is active: order by `-date_joined` (descending, most recent first)
   - Keep existing ordering for other search modes (`last_name`, `first_name`)
3. Integration with existing filters:
   - `recent_filter` works independently of `query` and `browse_range`
   - Status filter (`status_filter`) always applies regardless of search mode
   - Priority: If `recent_filter` is set, use it (similar to how `browse_range` works)
   - Mutually exclusive: If `recent_filter` is set, ignore `query` and `browse_range`
4. Add `date_joined` to context for template display

**Code Structure:**
```python
# After status filter is applied to base_queryset
if recent_filter:
    # Calculate cutoff date based on recent_filter value
    # Filter by date_joined >= cutoff_date
    # Order by -date_joined
elif browse_range:
    # Existing alphabet browse logic
elif query:
    # Existing search logic
```

**Step 2: Update Search Template (`members/templates/members/search.html`)**

**Changes:**
1. Add "Recently Added" button group:
   - Place between Status Filter and Alphabet Browse sections
   - Three buttons: "Last 30 Days", "Last 6 Months", "Last Year"
   - Style consistently with existing filter buttons (`btn-outline-primary btn-sm`)
   - Active state highlighting when filter is applied (`active` class)
   - Small label: "Or view recently added members:"
2. Update URL building:
   - Preserve `status_filter` when clicking recent filter buttons
   - Clear `query` and `browse_range` when recent filter is active
   - Add "Clear Filter" link when recent filter is active (similar to browse_range)
3. Update results display:
   - Add "Date Joined" information to member list items
   - Show date in readable format: "Joined: Nov 30, 2025" or "Joined: November 30, 2025"
   - Display alongside existing info (name, ID, status, expiration)
   - Placement: After Member Type or before Expiration date
4. Update results header:
   - Show "Recently Added Members" title when `recent_filter` is active
   - Show which filter is active (e.g., "Last 30 Days")
   - Include status filter in header if applied (e.g., "Last 30 Days (Active Only)")

**Template Structure:**
- Add new section after Status Filter buttons
- Update member list item template to include Date Joined
- Update all filter button URLs to preserve `recent_filter` parameter

#### Dependencies

- ✅ Change #004 (Reactivate Member Feature) - Completed (reactivation sets date_joined)
- ✅ Search functionality exists - Completed
- ✅ Member model has `date_joined` field - Completed

#### Testing Requirements

1. **Manual Testing:**
   - Click "Last 30 Days" filter and verify only members with date_joined in last 30 days are shown
   - Click "Last 6 Months" filter and verify only members with date_joined in last 180 days are shown
   - Click "Last Year" filter and verify only members with date_joined in last 365 days are shown
   - Verify results are ordered by date_joined descending (most recent first)
   - Verify Date Joined is displayed in results list
   - Verify reactivated members appear (since reactivation sets date_joined to today)
   - Verify newly created members appear
   - Verify filter works with status filter (e.g., "Last 30 Days + Active only")
   - Verify filter is mutually exclusive with text search and alphabet browse
   - Verify filter can be cleared
   - Test with members older than selected time period (should not appear)
   - Test with members exactly at the cutoff date (should appear)

2. **Edge Cases:**
   - Members exactly at cutoff date (should appear)
   - Members just before cutoff date (should not appear)
   - Members with no date_joined (should not appear or handle gracefully)
   - Empty result set
   - Large result sets (show all results, no limit)

3. **Automated Testing:**
   - Add test cases for recent members filter (30, 180, 365 days)
   - Test date filtering logic for each time period
   - Test ordering (most recent first)
   - Test integration with status filter
   - Test mutual exclusivity with query and browse_range
   - Test filter clearing

#### Benefits

- ✅ Quick access to recently added/reactivated members
- ✅ Three convenient time period options (30 days, 6 months, 1 year)
- ✅ Helps track new member growth over different time periods
- ✅ Useful for follow-up on new members
- ✅ Helps identify recent reactivations
- ✅ Improves member management workflow
- ✅ Date Joined visible in results for quick reference

#### Notes

- **Quick Filters Only**: No date range selector - just three preset buttons for simplicity
- **Show All Results**: No limit on number of results displayed (show all matching members)
- **Ordering**: Always ordered by `-date_joined` (most recent first) when recent filter is active
- **Reactivated Members**: Since Change #004 sets `date_joined` to today on reactivation, reactivated members will appear in this list
- **Performance**: Ensure query is optimized with proper indexing on `date_joined` field
- **Mutual Exclusivity**: Recent filter is mutually exclusive with text search (`q`) and alphabet browse (`browse`), but works with status filter
- **Future Enhancement**: Could add date range selector for custom date ranges
- **Future Enhancement**: Could add pagination if result sets become very large

---

### Change #006: Reports Landing Page & Recent Payments Report

**Status:** Planned  
**Priority:** Medium  
**Estimated Effort:** 3-4 hours  
**Created:** November 29, 2025

#### Description

Add a reports landing page with two banner links: one for the existing Current Members Report and another for a new Recent Payments Report. The Recent Payments Report will display all payments from the last year in reverse chronological order (latest first) with the ability to download as CSV. This provides easy access to payment history and enables data export for accounting/analysis purposes.

#### Current Implementation

**Location:** `members/templates/members/base.html` (sidebar), `members/views/reports.py`, `members/urls.py`

**Current Behavior:**
- Sidebar "Reports" link goes directly to `/reports/current-members/`
- Only one report available: Current Members Report (with PDF download)
- No way to view recent payments across all members
- No CSV export functionality for payments

**Current Code:**
```html
<!-- Sidebar link in base.html -->
<a href="{% url 'members:current_members_report' %}">
    Reports
</a>
```

#### Proposed Implementation

**New Features:**
1. **Reports Landing Page:**
   - Two banner cards/links:
     - "Current Members Report" → links to existing current members report
     - "Recent Payments Report" → links to new recent payments report
   - Clean, visual interface for selecting reports

2. **Recent Payments Report:**
   - Display all payments from last year (365 days)
   - Columns: Date, Last Name, First Name, Member ID, Payment Amount, Receipt Number
   - Ordered by date descending (most recent first)
   - HTML view for preview
   - CSV download button (similar to PDF download in current members report)

3. **CSV Export:**
   - Downloadable CSV file with all payment data
   - Filename format: `recent_payments_YYYY_MM_DD.csv`
   - Columns: Date, Last Name, First Name, Member ID, Payment Amount, Receipt Number
   - Proper CSV formatting with headers

**Key Changes:**
- Create reports landing page view and template
- Create recent payments report view
- Create CSV export function
- Update sidebar to link to landing page instead of direct report
- Add new URL routes for landing page and recent payments report

#### Implementation Steps

**Step 1: Create Reports Landing Page View (`members/views/reports.py`)**

- Add `reports_landing_view(request)` function
- Render landing page template with two banner cards
- Each card links to respective report
- Use `@staff_member_required` decorator

**Step 2: Create Recent Payments Report View (`members/views/reports.py`)**

- Add `recent_payments_report_view(request)` function
- Query payments from last year: `Payment.objects.filter(date__gte=one_year_ago)`
- Order by `-date` (reverse chronological, latest first)
- Use `select_related('member', 'payment_method')` for efficiency
- Handle CSV export: if `?format=csv`, call CSV generation function
- Otherwise render HTML template
- Pass payments queryset, report_date, and start_date to template

**Step 3: Create CSV Export Function (`members/reports/csv.py` - new file)**

- Create `generate_payments_csv(payments_queryset)` function
- Use Python's built-in `csv` module (no external library needed)
- Create `HttpResponse` with `content_type='text/csv'`
- Set Content-Disposition header for download filename
- Write CSV headers: Date, Last Name, First Name, Member ID, Payment Amount, Receipt Number
- Iterate through payments queryset and write rows
- Handle empty/null values gracefully (member_id, receipt_number)

**Step 4: Create Reports Landing Template (`members/templates/members/reports/landing.html` - new file)**

- Create landing page with two banner cards
- Each card contains:
  - Icon (Bootstrap Icons)
  - Title
  - Brief description
  - "View Report" button/link
- Style consistently with existing Bootstrap cards
- Two-column layout (col-md-6 each) for responsive design

**Step 5: Create Recent Payments HTML Template (`members/templates/members/reports/recent_payments.html` - new file)**

- Display payments in a table
- Table columns: Date, Member Name (Last, First), Member ID, Amount, Receipt Number
- Add "Download CSV" button in card header (similar to current members report PDF button)
- Show date range: "Payments from [start_date] to [report_date]"
- Show total count of payments
- Style consistently with `current_members.html` template
- Handle empty result set gracefully

**Step 6: Update URL Configuration (`members/urls.py`)**

- Add URL for reports landing page: `path("reports/", views.reports_landing_view, name="reports_landing")`
- Add URL for recent payments report: `path("reports/recent-payments/", views.recent_payments_report_view, name="recent_payments_report")`
- Keep existing current members report URL unchanged

**Step 7: Update Sidebar Navigation (`members/templates/members/base.html`)**

- Change Reports link from `current_members_report` to `reports_landing`
- Update active state check if needed (should still work with `'reports' in request.path`)

**Step 8: Update Views Init File (`members/views/__init__.py`)**

- Export new view functions: `reports_landing_view`, `recent_payments_report_view`
- Add to `__all__` list if present

#### Dependencies

- ✅ Payment model exists - Completed
- ✅ Member model exists - Completed
- ✅ Current members report exists - Completed
- ✅ Django's built-in `csv` module - Available (standard library)

#### Testing Requirements

1. **Manual Testing:**
   - Navigate to reports landing page and verify two banner cards appear
   - Click "Current Members Report" and verify it works as before
   - Click "Recent Payments Report" and verify payments display correctly
   - Verify payments are ordered by date descending (latest first)
   - Verify only payments from last year are shown
   - Click "Download CSV" and verify CSV file downloads
   - Open CSV file and verify:
     - Headers are correct
     - Data matches HTML view
     - Date format is correct (YYYY-MM-DD)
     - Empty member_id and receipt_number are handled correctly
   - Test with no payments in date range (empty result set)
   - Test with payments exactly at 365-day boundary

2. **Edge Cases:**
   - No payments in last year (empty result set)
   - Payments exactly 365 days ago (should appear)
   - Payments 366 days ago (should not appear)
   - Members with no member_id (should show empty string in CSV)
   - Payments with no receipt_number (should show empty string in CSV)
   - Large number of payments (performance testing)

3. **Automated Testing:**
   - Add test cases for reports landing page view
   - Add test cases for recent payments report view
   - Add test cases for CSV export function
   - Test date filtering logic
   - Test CSV formatting and headers
   - Test empty result sets

#### Benefits

- ✅ Centralized reports access point (landing page)
- ✅ Easy access to payment history across all members
- ✅ CSV export enables data analysis and accounting workflows
- ✅ Consistent user experience with existing reports
- ✅ Reverse chronological order helps identify recent activity
- ✅ One-year window provides comprehensive payment history

#### Notes

- **CSV Library**: Uses Python's built-in `csv` module (standard library, no installation needed)
- **Date Range**: Fixed at 365 days (1 year) - could be made configurable in future
- **Performance**: Uses `select_related()` to minimize database queries
- **File Naming**: CSV filename includes date for easy identification
- **Future Enhancement**: Could add date range selector (e.g., last 30 days, 6 months, 1 year)
- **Future Enhancement**: Could add filtering by payment method, member status, or amount range
- **Future Enhancement**: Could add PDF export similar to current members report

---

### Change #007: Admin Panel for Deactivating Expired Members

**Status:** Planned  
**Priority:** High  
**Estimated Effort:** 4-6 hours  
**Created:** December 06, 2025 at 07:06 PM

#### Description

Add a manual admin interface to deactivate members who are 90+ days past their expiration date and have no payment recorded after their expiration date. This provides control over the deactivation process, allowing administrators to review and select specific members before executing the deactivation.

#### Current Implementation

**Location:** `members/models.py` - `MemberManager.get_expired_for_deactivation()`

**Current Behavior:**
- `Member.objects.get_expired_for_deactivation()` finds active members expired 90+ days
- Does not check for payments after expiration date
- No admin interface to review or execute deactivation
- `Member.deactivate()` method exists but is not exposed in admin

**Current Code:**
```python
# members/models.py - Line 74-79
def get_expired_for_deactivation(self):
    """Get members who are expired 3+ months and should be deactivated"""
    from datetime import date, timedelta
    three_months_ago = date.today() - timedelta(days=90)
    return self.filter(status="active", expiration_date__lt=three_months_ago)
```

**Limitations:**
- No payment check (doesn't exclude members who paid after expiration)
- No admin UI to review members before deactivation
- No way to selectively deactivate specific members
- No visual feedback or confirmation

#### Proposed Implementation

**New Feature: Custom Django Admin Page**

A dedicated admin page accessible from the Django admin sidebar that:
1. Queries eligible members:
   - Status = "active"
   - Expiration date is 90+ days in the past
   - No payment recorded after expiration date
2. Displays a review list with:
   - Checkboxes for selection
   - Member details (ID, name, expiration date, days expired, last payment date)
   - Summary count
3. Allows selective deactivation:
   - Select individual members or "Select All"
   - Preview before executing
   - Execute deactivation with confirmation
4. Provides feedback:
   - Success messages showing count of deactivated members
   - Error handling for individual failures
   - List of members that were deactivated

**Key Changes:**
- Add new manager method: `get_expired_without_payment()` (includes payment check)
- Create custom admin view: `deactivate_expired_members_view()`
- Create admin template: `deactivate_expired.html`
- Register custom admin URL and menu item
- Add helper method to calculate days expired

#### Implementation Steps

**Step 1: Add Manager Method for Payment-Aware Query (`members/models.py`)**

**Location:** `MemberManager` class (around line 74)

**Add new method:**
```python
def get_expired_without_payment(self, days_threshold=90):
    """
    Get active members expired N+ days with no payment after expiration.
    
    Args:
        days_threshold: Number of days past expiration (default: 90)
    
    Returns:
        QuerySet of eligible members
    """
    from datetime import date, timedelta
    from django.db.models import Max
    
    cutoff_date = date.today() - timedelta(days=days_threshold)
    
    # Get active members expired beyond threshold
    expired_members = self.filter(
        status="active",
        expiration_date__lt=cutoff_date
    )
    
    # Annotate with last payment date after expiration
    expired_members = expired_members.annotate(
        last_payment_after_expiration=Max(
            'payments__date',
            filter=models.Q(payments__date__gt=models.F('expiration_date'))
        )
    )
    
    # Filter to only those with no payment after expiration
    return expired_members.filter(last_payment_after_expiration__isnull=True)
```

**Why this approach:**
- Uses annotation to find last payment after expiration
- Filters out members who paid after expiration
- Efficient single query
- Configurable threshold

**Step 2: Add Helper Method to Member Model (`members/models.py`)**

**Location:** `Member` class (around line 180)

**Add property/method:**
```python
def days_expired(self):
    """Calculate days since expiration date"""
    from datetime import date
    if self.expiration_date:
        return (date.today() - self.expiration_date).days
    return 0

@property
def last_payment_date(self):
    """Get the most recent payment date, or None"""
    last_payment = self.payments.order_by('-date').first()
    return last_payment.date if last_payment else None
```

**Step 3: Create Custom Admin View (`members/admin_views.py` - NEW FILE)**

**Create new file:** `members/admin_views.py`

**Purpose:** Handle GET (display list) and POST (execute deactivation) requests

**Implementation:**
```python
from django.contrib.admin.views.decorators import staff_member_required
from django.shortcuts import render, redirect
from django.contrib import messages
from django.db import transaction
from django.utils import timezone
from ..models import Member

@staff_member_required
def deactivate_expired_members_view(request):
    """
    Custom admin view for reviewing and deactivating expired members.
    
    GET: Display list of eligible members with checkboxes
    POST: Deactivate selected members
    """
    if request.method == 'POST':
        # Handle deactivation
        member_uuids = request.POST.getlist('member_uuids')
        
        if not member_uuids:
            messages.warning(request, "No members selected for deactivation.")
            return redirect('admin:deactivate_expired_members')
        
        # Get members and validate they're still eligible
        members = Member.objects.filter(
            member_uuid__in=member_uuids,
            status='active'
        )
        
        deactivated_count = 0
        errors = []
        
        with transaction.atomic():
            for member in members:
                try:
                    # Double-check eligibility before deactivating
                    if member.is_expired_for_deactivation():
                        # Check for payments after expiration
                        has_payment_after = member.payments.filter(
                            date__gt=member.expiration_date
                        ).exists()
                        
                        if not has_payment_after:
                            member.deactivate()
                            deactivated_count += 1
                        else:
                            errors.append(
                                f"{member.full_name} has a payment after expiration"
                            )
                    else:
                        errors.append(
                            f"{member.full_name} is not expired 90+ days"
                        )
                except Exception as e:
                    errors.append(f"Error deactivating {member.full_name}: {str(e)}")
        
        if deactivated_count > 0:
            messages.success(
                request,
                f"Successfully deactivated {deactivated_count} member(s)."
            )
        
        if errors:
            for error in errors:
                messages.error(request, error)
        
        return redirect('admin:deactivate_expired_members')
    
    # GET request - display list
    eligible_members = Member.objects.get_expired_without_payment()
    
    # Calculate days expired for each member
    members_with_info = []
    for member in eligible_members:
        members_with_info.append({
            'member': member,
            'days_expired': member.days_expired,
            'last_payment_date': member.last_payment_date,
        })
    
    # Sort by days expired (most expired first)
    members_with_info.sort(key=lambda x: x['days_expired'], reverse=True)
    
    context = {
        'members': members_with_info,
        'total_count': len(members_with_info),
        'title': 'Deactivate Expired Members',
    }
    
    return render(request, 'admin/deactivate_expired.html', context)
```

**Step 4: Create Admin Template (`members/templates/admin/deactivate_expired.html` - NEW FILE)**

**Create new file:** `members/templates/admin/deactivate_expired.html`

**Purpose:** Display list of eligible members with selection interface

**Template Structure:**
```django
{% extends "admin/base_site.html" %}
{% load static %}

{% block title %}Deactivate Expired Members{% endblock %}

{% block content %}
<div class="content">
    <h1>Deactivate Expired Members</h1>
    
    <div class="module">
        <div class="form-row">
            <p class="help">
                Found <strong>{{ total_count }}</strong> member(s) expired 90+ days 
                with no payment after expiration date.
            </p>
        </div>
        
        {% if members %}
        <form method="post" id="deactivate-form">
            {% csrf_token %}
            
            <div class="form-row">
                <label>
                    <input type="checkbox" id="select-all" />
                    <strong>Select All</strong>
                </label>
            </div>
            
            <table class="table">
                <thead>
                    <tr>
                        <th>Select</th>
                        <th>Member ID</th>
                        <th>Name</th>
                        <th>Expiration Date</th>
                        <th>Days Expired</th>
                        <th>Last Payment</th>
                        <th>Member Type</th>
                    </tr>
                </thead>
                <tbody>
                    {% for item in members %}
                    <tr>
                        <td>
                            <input type="checkbox" 
                                   name="member_uuids" 
                                   value="{{ item.member.member_uuid }}"
                                   class="member-checkbox" />
                        </td>
                        <td>{{ item.member.member_id|default:"—" }}</td>
                        <td>
                            <a href="{% url 'admin:members_member_change' item.member.member_uuid %}">
                                {{ item.member.full_name }}
                            </a>
                        </td>
                        <td>{{ item.member.expiration_date|date:"M d, Y" }}</td>
                        <td>
                            <span class="badge badge-warning">{{ item.days_expired }} days</span>
                        </td>
                        <td>
                            {% if item.last_payment_date %}
                                {{ item.last_payment_date|date:"M d, Y" }}
                            {% else %}
                                <span class="text-muted">No payments</span>
                            {% endif %}
                        </td>
                        <td>{{ item.member.member_type }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            
            <div class="submit-row">
                <button type="submit" 
                        class="default" 
                        onclick="return confirm('Are you sure you want to deactivate the selected members? This action cannot be undone.');">
                    Deactivate Selected
                </button>
                <a href="{% url 'admin:index' %}" class="button">Cancel</a>
            </div>
        </form>
        
        <script>
            // Select All functionality
            document.getElementById('select-all').addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('.member-checkbox');
                checkboxes.forEach(cb => cb.checked = this.checked);
            });
        </script>
        {% else %}
        <div class="form-row">
            <p class="help">No members found matching the criteria.</p>
        </div>
        {% endif %}
    </div>
</div>
{% endblock %}
```

**Step 5: Register Custom Admin URL (`members/admin.py`)**

**Location:** Add to end of `members/admin.py`

**Simpler Approach - Monkey-patch admin site:**
```python
# At end of members/admin.py
from django.urls import path
from .admin_views import deactivate_expired_members_view

# Monkey-patch admin site to add custom URL
original_get_urls = admin.site.get_urls

def custom_get_urls():
    urls = original_get_urls()
    custom_urls = [
        path(
            'deactivate-expired-members/',
            admin.site.admin_view(deactivate_expired_members_view),
            name='deactivate_expired_members',
        ),
    ]
    return custom_urls + urls

admin.site.get_urls = custom_get_urls
```

**Step 6: Add Admin Menu Item (`members/admin.py`)**

**Location:** Create template override for Member admin changelist

**Simplest Approach - Option C: Add link in Member admin via changelist template**

**Create:** `members/templates/admin/members/member/change_list.html`
```django
{% extends "admin/change_list.html" %}

{% block object-tools-items %}
    {{ block.super }}
    <li>
        <a href="{% url 'admin:deactivate_expired_members' %}" class="addlink">
            Deactivate Expired Members
        </a>
    </li>
{% endblock %}
```

This adds a link in the Member admin changelist page's object tools section.

**Step 7: Update URL Configuration (if needed)**

**Location:** `alano_club_site/urls.py`

**Check if admin URLs are configured correctly:**
- Admin URLs should already be set up
- Custom admin URLs will be added via admin site override (Step 5)

**Step 8: Add Tests (`tests/test_admin_views.py` - NEW FILE)**

**Create test file for admin views:**
```python
from django.test import TestCase, Client
from django.contrib.auth.models import User
from members.models import Member, MemberType, Payment, PaymentMethod
from datetime import date, timedelta

class TestDeactivateExpiredMembersView(TestCase):
    def setUp(self):
        # Create staff user
        self.user = User.objects.create_user(
            username='admin',
            password='testpass',
            is_staff=True
        )
        self.client = Client()
        self.client.login(username='admin', password='testpass')
        
        # Create member type
        self.member_type = MemberType.objects.create(
            member_type='Regular',
            member_dues=30.00,
            num_months=1
        )
        
        # Create payment method
        self.payment_method = PaymentMethod.objects.create(
            payment_method='Cash'
        )
    
    def test_get_view_displays_eligible_members(self):
        # Create expired member without payment
        expired_date = date.today() - timedelta(days=95)
        member = Member.objects.create(
            first_name='John',
            last_name='Doe',
            member_type=self.member_type,
            status='active',
            expiration_date=expired_date,
            date_joined=date.today() - timedelta(days=200)
        )
        
        response = self.client.get('/admin/deactivate-expired-members/')
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'John Doe')
    
    def test_get_view_excludes_members_with_payment_after_expiration(self):
        # Create expired member with payment after expiration
        expired_date = date.today() - timedelta(days=95)
        member = Member.objects.create(
            first_name='Jane',
            last_name='Smith',
            member_type=self.member_type,
            status='active',
            expiration_date=expired_date,
            date_joined=date.today() - timedelta(days=200)
        )
        
        # Add payment after expiration
        Payment.objects.create(
            member=member,
            payment_method=self.payment_method,
            amount=30.00,
            date=expired_date + timedelta(days=10)  # After expiration
        )
        
        response = self.client.get('/admin/deactivate-expired-members/')
        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, 'Jane Smith')
    
    def test_post_view_deactivates_selected_members(self):
        # Create expired member
        expired_date = date.today() - timedelta(days=95)
        member = Member.objects.create(
            first_name='Bob',
            last_name='Johnson',
            member_type=self.member_type,
            status='active',
            expiration_date=expired_date,
            date_joined=date.today() - timedelta(days=200),
            member_id=42
        )
        
        response = self.client.post(
            '/admin/deactivate-expired-members/',
            {'member_uuids': [str(member.member_uuid)]}
        )
        
        member.refresh_from_db()
        self.assertEqual(member.status, 'inactive')
        self.assertIsNone(member.member_id)
```

#### Dependencies

- ✅ Member model with `expiration_date`, `status`, `deactivate()` method - Completed
- ✅ Payment model with `date` field and ForeignKey to Member - Completed
- ✅ Django admin interface - Completed
- ✅ Staff user authentication - Completed

#### Testing Requirements

1. **Manual Testing:**
   - Access admin panel and navigate to "Deactivate Expired Members" (via Member admin link)
   - Verify list shows only eligible members (90+ days expired, no payment after expiration)
   - Verify members with payments after expiration are excluded
   - Verify "Select All" checkbox works
   - Select individual members and verify deactivation
   - Verify success messages display correctly
   - Verify deactivated members have status="inactive" and member_id=None
   - Verify date_inactivated is set
   - Test with empty result set (no eligible members)
   - Test with members exactly 90 days expired
   - Test with members 89 days expired (should not appear)

2. **Edge Cases:**
   - Member becomes active between page load and deactivation
   - Member receives payment between page load and deactivation
   - Multiple admins deactivating simultaneously
   - Very large result sets (performance)
   - Members with no payments at all
   - Members with payments before expiration but not after

3. **Automated Testing:**
   - Test `get_expired_without_payment()` manager method
   - Test payment filtering logic
   - Test admin view GET request (display list)
   - Test admin view POST request (deactivate selected)
   - Test authentication/authorization (staff only)
   - Test error handling
   - Test transaction atomicity

#### Benefits

- ✅ Manual control over deactivation process
- ✅ Review before executing
- ✅ Selective deactivation of specific members
- ✅ Payment-aware filtering (excludes members who paid after expiration)
- ✅ Visual feedback and confirmation
- ✅ Integrated with Django admin
- ✅ Uses existing `deactivate()` method
- ✅ Audit trail via admin messages

#### Notes

- **Payment Rule**: Option B - No payment after expiration date (members who paid after expiration are excluded)
- **Implementation**: Option 1 - Custom Django admin page
- **Threshold**: 90 days (configurable via method parameter)
- **Deactivation**: Uses existing `Member.deactivate()` method
- **Transaction Safety**: Uses `transaction.atomic()` for batch operations
- **Performance**: Uses annotation for efficient querying
- **Future Enhancement**: Add filtering by days expired (e.g., 90+, 120+, 180+)
- **Future Enhancement**: Add search by name
- **Future Enhancement**: Add export to CSV
- **Future Enhancement**: Add "undo" functionality (reactivate)

#### Files to Create/Modify

**New Files:**
1. `members/admin_views.py` - Custom admin view
2. `members/templates/admin/deactivate_expired.html` - Admin template
3. `members/templates/admin/members/member/change_list.html` - Add menu link
4. `tests/test_admin_views.py` - Test suite

**Modified Files:**
1. `members/models.py` - Add `get_expired_without_payment()` method and helper properties
2. `members/admin.py` - Register custom admin URL (monkey-patch approach)

---

## Template for New Changes

### Change #XXX: [Title]

**Status:** Planned  
**Priority:** [High/Medium/Low]  
**Estimated Effort:** [Time estimate]  
**Created:** [Date]

#### Description
[What needs to be changed and why]

#### Current Implementation
[How it currently works]

#### Proposed Implementation
[How it should work]

#### Implementation Steps
1. Step 1: [Description]
2. Step 2: [Description]
3. Step 3: [Description]

#### Dependencies
- [What needs to be completed first]

#### Testing Requirements
- [How to verify it works]

#### Benefits
- [Why this change is valuable]

#### Notes
[Any additional considerations]

---

